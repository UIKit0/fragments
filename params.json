{"name":"Fragments","tagline":"tool for diff-based templating / fragmentation control","body":"Fragments\r\n=========\r\n\r\nFragments uses concepts from version control to replace many uses of templating languages.\r\nInstead of a templating language, it provides diff-based templating;\r\ninstead of revision control, it provides \"fragmentation control\".\r\n\r\nFragments is a [DRY (Don't Repeat Yourself)](http://en.wikipedia.org/wiki/Don't_repeat_yourself) violation manager;\r\nit is a [Multiple Source of Truth](http://en.wikipedia.org/wiki/Single_Source_of_Truth) engine.\r\n\r\nWhat is diff-based templating?\r\n------------------------------\r\n\r\nGenerating HTML with templating languages is difficult because templating languages often have two semi-incompatible purposes.\r\nThe first purpose is managing common HTML elements & structure: headers, sidebars, and footers; across multiple templates.\r\nThis is sometimes called page \"inheritance\".\r\nThe second purpose is to perform idiosyncratic display logic on data coming from another source.\r\nWhen these two purposes can be separated, templates can be much simpler.\r\n\r\nFragments manages this first purpose, common HTML elements and structure, with diff and merge algorithms.\r\nThe actual display logic is left to your application, or to a templating language whose templates are themselves managed by Fragments.\r\n\r\nWhat is fragmentation control?\r\n------------------------------\r\n\r\nThe machinery to manage common and different code fragments across multiple versions of _a single file_ already exists in modern version control systems.\r\nFragments adapts these tools to manage common and different versions of _several different files_.\r\n\r\nEach file is in effect its own \"branch\", and whenever you modify a file (\"branch\") you can apply (\"merge\") that change into whichever other files (\"branches\") you choose.\r\nIn this sense Fragments is a different kind of \"source control\"--rather than controlling versions/revisions over time, it controls fragments across many files that all exist simultaneously.\r\nHence the term \"fragmentation control\".\r\n\r\nAs I am a linguist, I have to point out that the distinction between [Synchronic](http://en.wikipedia.org/wiki/Synchronic_analysis) and [Diachronic](http://en.wikipedia.org/wiki/Diachronics) Linguistics gave me this idea in the first place.\r\n\r\nHow does it work?\r\n-----------------\r\n\r\nThe merge algorithm is a version of [Precise Codeville Merge](http://revctrl.org/PreciseCodevilleMerge) modified to support cherry-picking.\r\nPrecise Codeville Merge was chosen because it supports [accidental clean merges](http://revctrl.org/AccidentalCleanMerge) and [convergence](http://revctrl.org/Convergence).\r\nThat is, if two files are independently modified in the same way, they merge together cleanly.\r\nThis makes adding new files easy; use Fragment's `fork` command to create a new file based on other files (or just `cp` one of your files), change it as desired, and commit it.\r\nSubsequent changes to any un-modified, common sections, in that file or in its siblings, will be applicable across the rest of the repository.\r\n\r\nLike version control, you run Fragments on the command line each time you make a change to your HTML, not before each page render.\r\n\r\nWhat is it good for?\r\n--------------------\r\n\r\nFragments was designed with the task of simplifying large collections of HTML or HTML templates.\r\nIt could replace simpler CMS-managed websites with pure static HTML.\r\nIt could also handle several different translations of an HTML website, ensuring that the same HTML structure was wrapped around each translation of the content.\r\n\r\nBut Fragments is also not HTML specific.\r\nIf it's got newlines, Fragments can manage it.\r\nThat means XML, CSS, JSON, YAML, or source code from any programming language where newlines are common (sorry, Perl).\r\ncFragments is even smart enough to know not to merge totally different files together.\r\nYou could use it to manage a large set of configuration files for different servers and deployment configurations, for example.\r\nOr you could use it to manage bug fixes to that mess of duplicated source files on that legacy project you wish you didn't have to maintain.\r\n\r\nIn short, Fragments can be used anyplace where you have thought to yourself \"this group of files really is violating DRY\".\r\n\r\nIntegration with version control\r\n--------------------------------\r\n\r\nFragments has no history; It only stores the previous committed state of a file.\r\nStoring history is up to your version control system.\r\nBut Fragments stores its repository configuration in such a way to allow your version control system to manage it painlessly and obviously.\r\nConfiguration is stored in a `_fragments` directory.\r\nThis directory name is not preceded by a `.`, and all the files in it are stored as plain text.\r\nYou want to make sure to run `fragments init` from your repository root, which is usually at least one directory level above your actual content.\r\nOtherwise your `_fragments` directory may get accidentally deployed to production or interfere with template loaders.\r\n\r\nThe `rename` and `forget` commands in Fragments are written to not interfere with a version control's rename and remove commands, as these commands sometimes need to be used in tandem.\r\n\r\nInvisibility\r\n------------\r\n\r\nFragments is invisible to people who don't know it's being used.\r\nIf you (or someone else) make more than one change to a file, Fragments' `apply` command allows you to perform chunk-based interactive application of changes, similar to `git commit --patch` or `hg record`.\r\nSo, you can give a single HTML file to your web designer or junior programmer, let him or her modify it as desired.\r\nLater, you can selectively apply some of those changes across all other HTML files, while leaving other changes only in the modified file.\r\n\r\nInstallation\r\n------------\r\n\r\nFragments is [on PyPI](http://pypi.python.org/pypi/fragments).\r\nYou can install it with `pip install fragments`.\r\n\r\nUsage\r\n-----\r\n\r\nFragments installs a `fragments` command line script.\r\nLike version control, the first argument to Fragments is the command.\r\nAnd like version control, you must first `$ fragments init` a repository, then `$ fragments follow` some files, then `$ fragments commit` them.\r\nDeliberately different command names are used in some cases, to remind you that Fragments is not version control.\r\n\r\nIf you are red-green color-blind (protanopic or deutanopic), set the `COLORBLIND` environment variable to `protan` or `deutan` and fragments will use blue instead of green for displaying added lines.\r\n\r\n    export COLORBLIND=protan\r\n\r\nCommands\r\n--------\r\n\r\n* `help [COMMAND]`\r\n\r\n    Display global help, or help for _COMMAND_ if specified.\r\n\r\n* `init [FRAGMENTS_ROOT]`\r\n\r\n    Initialize a new fragments repository.\r\n    Repository is in a directory named `_fragments/`, created in either the current working directory, or _FRAGMENTS\\_ROOT_ if specified.\r\n\r\n* `status [[ -l | --limit] STATUS ] [FILENAME [FILENAME ...]]`\r\n\r\n    Get the current status of the fragments repository, limited to _FILENAME_(s) if specified.\r\n    Limit output to files with status _STATUS_, if present.\r\n\r\n* `follow FILENAME [FILENAME ...]`\r\n\r\n    Start following changes to one or more _FILENAME_(s).\r\n\r\n* `forget FILENAME [FILENAME ...]`\r\n\r\n    Stop following changes to one or more _FILENAME_(s).\r\n\r\n* `rename OLD_FILENAME NEW_FILENAME` or `rename OLD_FILENAME [OLD_FILENAME ...] NEW_DIRECTORY`\r\n\r\n    Rename _OLD\\_FILENAME_ to _NEW\\_FILENAME_ or move _OLD\\_FILENAME_(s) to _NEW\\_DIRECTORY_.\r\n    File(s) on disk, including unfollowed files, are moved, if they are not already in the new location.\r\n\r\n* `move` is an alias for `rename`\r\n\r\n* `diff [[-U | --unified] NUM] [FILENAME [FILENAME ...]]`\r\n\r\n    Show differences between committed and uncommitted versions, limited to _FILENAME_(s) if specified.\r\n\r\n    `-U NUM`, `--unified NUM` number of lines of context to show\r\n\r\n* `commit [FILENAME [FILENAME ...]]`\r\n\r\n    Commit changes to the fragments repository, limited to _FILENAME_(s) if specified.\r\n\r\n* `revert [FILENAME [FILENAME ...]]`\r\n\r\n    Revert changes to the fragments repository, limited to _FILENAME_(s) if specified.\r\n\r\n* `fork [[-U | --unified] NUM] SOURCE_FILENAME [SOURCE_FILENAME ...] TARGET_FILENAME`\r\n\r\n    Create a new file in _TARGET\\_FILENAME_ based on one or more _SOURCE\\_FILENAME_(s).\r\n    Large common sections are preserved;\r\n    differing sections, and common sections shorter than _NUM_ lines between differing sections, are replaced with one newline for each line or conflict.\r\n\r\n* `apply [-i | -a] [[-U | --unified] NUM] SOURCE_FILENAME [TARGET_FILENAME [TARGET_FILENAME ...]]`\r\n\r\n    Apply changes in _SOURCE\\_FILENAME_ that were made since last commit, where possible.\r\n    Limit application to _TARGET\\_FILENAME_(s) if specified.\r\n    Files that conflict in their entirety will be skipped.\r\n    Smaller conflicts will be written to the file as conflict sections.\r\n\r\n    `-i, --interactive` interactively select changes to apply\r\n\r\n    `-a, --automatic` automatically apply all changes\r\n\r\n    `-U NUM`, `--unified NUM` number of lines of context to show\r\n\r\n    In interactive mode, you can use the following commands:\r\n\r\n    * `y` include this change\r\n    * `n` do not include this change\r\n    * `a` include this change and all remaining changes\r\n    * `d` done, do not include this change nor any remaining changes\r\n    * `j` leave this change undecided, see next undecided change\r\n    * `k` leave this change undecided, see previous undecided change\r\n    * `?` interactive apply mode help\r\n\r\nFuture improvements\r\n-------------------\r\n\r\n### Preprocessors\r\n\r\nSince Fragments is diff-based, it will not do well with minified or otherwise compressed content.\r\nDo not expect it to handle changes to your 10,000 character, single line, über-compressed CSS or JavaScript file, or to the inline JavaScript function in an `onclick` attribute in your HTML.\r\nThe more newlines there are in your files, the more robust Fragments' merging will be.\r\n\r\nAdding preprocessors to enforce consistent newline placement and indentation across all followed files would potentially make Fragments' merging even more robust.\r\nThe preprocessors would run before `commit`, `fork`, and `apply`, and there would be different preprocessors for different file formats.\r\n\r\n### Miscellaneous improvements\r\n\r\n* Better command-line completion mode for bash\r\n* Command-line completion mode for zsh\r\n* Command aliasing and default configuration\r\n* Pluggable diff & merge algorithms, if they prove useful\r\n\r\nCredits\r\n-------\r\n\r\nFragments is Copyright 2012 by Matt Chisholm, and is released under the BSD License.\r\nIt is available [on GitHub](https://github.com/glyphobet/fragments) and [on PyPI](http://pypi.python.org/pypi/fragments).\r\nMany thanks to Ross Cohen for his thoughts on the idea, and for preparing Precise Codeville Merge for use in Fragments.\r\n","google":"UA-32742441-1","note":"Don't delete this file! It's used internally to help with page regeneration."}